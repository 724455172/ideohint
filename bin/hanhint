#!/usr/bin/env node
var fs = require('fs');
var readline = require('readline');
var stream = require('stream');
var instruct = require('../instructor').instruct;
var devnull = require('dev-null');
var colors = require('colors');
var util = require('util');

var yargs = require('yargs')
	.alias('o', 'output-into')
	.alias('?', 'help')
	.alias('silent', 'quiet')
	.alias('verbose', 'v')
	.boolean(['just_modify_cvt', 'silent', 'verbose'])
	.usage('$0 [Options] [<input.sfd>] [-o <output.sfd>]\n\
	       |Replace gridfit instructions in quadtaric SFD input file and rewrite the output file.\n\
	       |When the output file is missing, standard output is used instead.\n\
	       |When the input file is missing, standard input is used isntead.\n\
	       |\n\
	       |The new gridfits are optimized for Han characters.\n\
	       |'.replace(/^\s*\|/gm, ''))
	.describe('help', 'Displays this help.')
	.describe('o', 'Output sfd path. When absent, the result sfd is written to STDOUT.')
	.describe('UPM', 'Specify the units-per-em (upm) value for the input. Default: 1000.')
	.describe('PPEM_MIN', 'Switch hints below this PPEM value. Default: 10.')
	.describe('PPEM_MAX', 'Switch hints above this PPEM value. Default: 36.')
	.describe('silent', 'Run in quiet mode')
	.describe('verbose', 'Run in verbose mode')
	.describe('just_modify_cvt', 'Don\'t change any Truetype insructions, just append items into the cvt table.')

var argv = yargs.argv;

if(argv.help) {
	yargs.showHelp();
	process.exit(0)
}

var instream = argv._[0] ? fs.createReadStream(argv._[0]): process.stdin;
var outstream = argv.o ? fs.createWriteStream(argv.o, { encoding: 'utf-8' }): process.stdout;
var rl = readline.createInterface(instream, devnull());

var n = 0;
var buf = '';

var strategy = {
	UPM: 1000,
	MIN_STEM_WIDTH: 20,
	MAX_STEM_WIDTH: 140,
	STEM_SIDE_MIN_RISE: 40,
	STEM_SIDE_MIN_DESCENT: 60,
	PPEM_MIN: 10,
	PPEM_MAX: 36,
	POPULATION_LIMIT: 500,
	CHILDREN_LIMIT: 150,
	EVOLUTION_STAGES: 20,
	MUTANT_PROBABLITY: 0.2,
	ELITE_COUNT: 10,
	WIDTH_FACTOR_X: 2,
	MIN_ADJUST_PPEM: 16,
	MAX_ADJUST_PPEM: 36,
	MIN_TOUCHED_STEM_WIDTH: 2,
	LOW_PPEM_LIMIT: 20,
	FORCE_LOW_PPEM_LIMIT: 13,
	MIN_LOW_PPEM_STEM_WIDTH: 1,
	ABLATION_IN_RADICAL: 1,
	ABLATION_RADICAL_EDGE: 2,
	ABLATION_GLYPH_EDGE: 15,
	ABLATION_GLYPH_HARD_EDGE: 25,
	COEFF_PORPORTION_DISTORTION: 4,
	BLUEZONE_BOTTOM_CENTER: -75,
	BLUEZONE_TOP_CENTER: 840,
	BLUEZONE_BOTTOM_LIMIT: -65,
	BLUEZONE_TOP_LIMIT: 825,
	BLUEZONE_WIDTH: 15,
	COEFF_A_MULTIPLIER: 5,
	COEFF_A_SAME_RADICAL: 4,
	COEFF_A_FEATURE_LOSS: 15,
	COEFF_A_RADICAL_MERGE: 1,
	COEFF_C_MULTIPLIER: 25,
	COEFF_C_SAME_RADICAL: 6,
	COEFF_S: 10000,
	COEFF_A_SYMMETRY: -40,
	COLLISION_MIN_OVERLAP_RATIO: 0.2,
	DONT_ADJUST_STEM_WIDTH: false
};

for(var prop in strategy) {
	if(argv[prop]) {
		strategy[prop] = isFinite(argv[prop] - 0) ? argv[prop] : strategy[prop]
	}
};

function pushWhenAbsent(a, x){
	a.push(x)
}

function createCvt(src, padding){
	var MAX_SW = 3;
	var cvt = (src || []).slice(0);
	padding = padding || 0;
	while(cvt.length < padding) cvt.push(0);
	pushWhenAbsent(cvt, 0);
	pushWhenAbsent(cvt, strategy.BLUEZONE_TOP_CENTER);
	pushWhenAbsent(cvt, strategy.BLUEZONE_BOTTOM_CENTER)
	for(var w = 1; w <= MAX_SW; w++){
		for(var ppem = strategy.PPEM_MIN; ppem < strategy.PPEM_MAX; ppem++){
			pushWhenAbsent(cvt, -Math.round(strategy.UPM / ppem * w))
		}
	};
	for(var w = 1; w <= MAX_SW; w++){
		for(var ppem = strategy.PPEM_MIN; ppem < strategy.PPEM_MAX; ppem++){
			pushWhenAbsent(cvt, Math.round(strategy.UPM / ppem * w))
		}
	};
	return cvt;
};

var cvt = createCvt([], argv.CVT_PADDING);
if(argv.use_cvt) cvt = JSON.parse(fs.readFileSync(argv.usd_cvt, 'utf-8')).cvt

var curChar = null;
var readingSpline = false;
var readingTT = false;
if(!argv.silent) process.stderr.write("[Start]    ".yellow + "Start hinting " + (argv._[0] || '(stdin)').green + '\n');
var sourceCvt = '';
var readingCvt = false;
rl.on('line', function(line) {

	if(/^ShortTable: cvt /.test(line)) {
		sourceCvt += line + "\n";
		readingCvt = true;
		return;
	} else if(readingCvt) {
		sourceCvt += line + "\n";
		if(/^EndShort/.test(line)) { 
			readingCvt = false;
			cvt = createCvt(sourceCvt.trim().split('\n').slice(1, -1).map(function(x){ return x.trim() - 0 }), argv.CVT_PADDING);
			if(argv.dump_cvt) {
				fs.writeFileSync(argv.dump_cvt, JSON.stringify({cvt: cvt}), 'utf-8')
			}
		};
		return;
	} else if(/^StartChar:/.test(line)) {
		curChar = { input: '', id: line.split(' ')[1] }
	} else if(/^SplineSet/.test(line)) {
		readingSpline = true;
	} else if(/^EndSplineSet/.test(line)) {
		readingSpline = false;
	} else if(curChar && readingSpline) {
		curChar.input += line + '\n';
	} else if(/^EndChar/.test(line)) {
		if(curChar){
			if(!argv.silent && n % (argv.verbose ? 1: 100) === 0) {
				process.stderr.write("[Progress] ".yellow + "Hinting /" + curChar.id + ' of ' + (argv._[0] || '(stdin)').green + '\n')
			};
			if(!argv.just_modify_cvt) {
				var instructions = instruct(curChar.input, strategy, cvt, argv.CVT_PADDING)
				if(instructions) buf += "TtInstrs:\n" + instructions + "\nEndTTInstrs\n";
			}
			n++;
		};
		curChar = null;
	} else if(/^BeginChars:/.test(line)) {
		buf += 'ShortTable: cvt  ' + cvt.length + '\n' + cvt.join('\n') + '\nEndShort\n'
	};

	buf += line + '\n';
	if(buf.length >= 4096) {
		outstream.write(buf);
		buf = '';
	}
});

rl.on('close', function() {
	if(buf) outstream.write(buf);
	outstream.end();
	if(!argv.silent) process.stderr.write("[Done]     ".yellow + "Done hinting " + (argv._[0] || '(stdin)').green + '\n')
});
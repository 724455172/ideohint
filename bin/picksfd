#!/usr/bin/env node
var fs = require('fs');
var readline = require('readline');
var stream = require('stream');
var devnull = require('dev-null');


var crypto = require('crypto');
function md5 (text) {
	return crypto.createHash('md5').update(text).digest('hex');
};

var yargs = require('yargs');
var argv = yargs.argv;

if(argv.help) {
	yargs.showHelp();
	process.exit(0)
}

var instream = argv._[0] ? fs.createReadStream(argv._[0]): process.stdin;
var outstream = argv.o ? fs.createWriteStream(argv.o, { encoding: 'utf-8' }): process.stdout;
var w = argv.w;
var matches = [];
var rl = readline.createInterface(instream, devnull());

var started = false;

var curChar = null;
var readingSpline = false;

rl.on('line', function(line) {

	if(/^StartChar:/.test(line)) {
		curChar = { input: '', id: line.split(' ')[1] }
	} else if(curChar && /^Encoding:/.test(line)){
		curChar.encoding = line.split(' ')[2] - 0;
	} else if(/^SplineSet/.test(line)) {
		readingSpline = true;
	} else if(/^EndSplineSet/.test(line)) {
		readingSpline = false;
	} else if(curChar && readingSpline) {
		curChar.input += line + '\n';
	} else if(/^EndChar/.test(line)) {
		if(curChar && curChar.encoding) {
			for(var k = 0; k < w.length; k++) if(curChar.encoding === w.charCodeAt(k)){
				matches[k] = 'SplineSet\n' + curChar.input + '\nEndSplineSet';
			}
		};
		curChar = null;
	};
});

rl.on('close', function() {
	outstream.write('\n\n' + matches.join('\n\n'))
});